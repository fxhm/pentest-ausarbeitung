\subsection{Pass-The-Hash}
\subsubsection{LAN Manager}
 LAN Manager (auch bekannt als LANMAN) ist ein Netzwerkbetriebssystem das in Microsoft-Betriebssystemen zum Einsatz kommt. Es dient zum Bereitstellen von Ressourcen (Laufwerke, Verzeichnisse, Drucker, serielle Geräte) im Netzwerk.
    Zur Authentifizierung im Netzwerk werden Passwort-Hashes verwendet. Die eingesetzte Hashfunktion "LM Hash" weist jedoch große Schwächen auf und ist mit Rainbow Tables innerhalb von Sekunden, mit der Brute-Force-Methode innerhalb weniger Stunden knackbar.
    Ab Windows NT wurde LAN Manager durch NT LAN Manager (NTLM) ersetzt. LAN Manager ist jedoch bis heute aus Legacy-Gründen in Microsoft-Betriebssystemen enthalten. Erst ab Windows Vista ist es standardmäßig deaktiviert.
\subsubsection{New Technology LAN Manager (NTLM)}
    NTLM ist ein Authentifizierungsverfahren für Rechnernetze, das ursprünglich properitär von Microsoft entwickelt wurde. Es ist der Nachfolger von LAN Manager und bis heute auch in modernen Computersystemen im Einsatz. Die in NTLM eingesetzte Hashfunktion "NTLM Hash" ist ähnlich schwach wie ihr Vorgänger. Mit moderner Hardware ist sie innerhalb weniger Stunden knackbar (Stand 2019: weniger als 2,5 Stunden für ein 8-Zeichen-Passwort).
\subsubsection{Der Pass-The-Hash-Angriff}
    Pass-The-Hash ist ein Angriff, der es dem Angreifer ermöglicht, sich mit dem LM- oder NTLM-Hashwert eines Passworts gegenüber einem Server zu authentifizieren. Das Passwort im Klartext wird dazu nicht benötigt, somit erübrigt sich auch die rechenaufwendige Anwendung der Brute-Force-Methode zum Knacken des Passwort-Hashes. Verwundbar für den Angriff sind alle Systeme, die eine NT- oder NTLM-Authentifizierung akzeptieren.
    Um den Angriff durchführen zu können, muss jedoch erst ein LM- oder NTLM-Hashwert des Passworts, sowie der zugehörige Benutzername beschafft werden.

\paragraph{Beschaffung des Passwort-Hashes}

\begin{itemize}
\item Falls der Angreifer auf einem Windows-System über Administratorrechte verfügt, kann er die gecachten Hashwerte der Passwörter aller Nutzer auslesen, die sich auf dem System angemeldet haben (dies gilt auch für die Anmeldung über Remote Desktop Protocol (RDP) und Konsole). Diese Hashwerte befinden sich in der Datenbank des Security Account Managers (SAM). Die Cache-Einstellungen lassen sich jedoch so ändern, dass diese Vorgehensweise nicht mehr erfolgreich ist.
\item Durch Dumping der SAM-Datenbank des lokal angemeldeten Benutzers kann der Angreifer die Passwort-Hashes dieses lokalen Benutzers akquirieren.
\item Das Abhören des LAN Manager- bzw. NT LAN Manager-Challenge-Response-Dialogs, der bei der Anmeldung durchgeführt wird, ermöglicht es dem Angreifer, an den verschlüsselten Hashwert eines Passworts zu gelangen. Diese Verschlüsselung kann wiederum mit Hilfe der Brute-Force-Methode gebrochen werden.
\item Der Angreifer hat auch die Möglichkeit, die Anmeldedaten von authentifizierten Benutzern aus dem Speicherauszug des lsass.exe-Prozesses auszulesen. Auch hier können sich die Passwort-Hashes von über RDP angemeldeten Benutzern befinden.
\end{itemize}


\subsection{Kerberos}

Kerberos ist ein verteilter Authentifizierungsdienst für Rechnernetze, der am MIT entwickelt wurde. Die erste Veröffentlichung erschien 1978, aktuell (Stand 2019)ist Kerberos 5. Im Folgenden soll zunächst auf den Protokollablauf eingegangen werden darauf folgt die Erläuterung einiger Angriffsszenarien.

\paragraph{Abkürzungen}
\begin{itemize}
\item[KDC] Key Distribution Center
\item[AS] Authentication Server
\item[TGT] Ticket Granting Ticket
\item[TGS] Ticket Granting Service
\item[SPN] Service Principal Name
\item[SS] Service Server
\end{itemize}
\subsubsection{Protokollablauf}

\begin{itemize}
\item[1)] Der Client sendet eine Nachricht, die lediglich seine Nutzer-ID ''u\_id'' enthält im Klartext and den AS. Es wird hier also kein Passwort oder geheimer Schlüssel übertragen.
\item[2)] Der AS sucht in der Datenbank nach der Nutzer-ID aus der eben erhaltenen Nachricht. Falls er sie findet, berechnet er den Hashwert des ebenfalls in der Datenbank enthaltenen Passworts des Nutzers. Der AS schickt dann folgende Nachrichten an den Client:
\begin{itemize}
\item[A)] TGS-Sitzungsschlüssel ''tgs\_session\_key'', verschlüsselt mit dem zuvor berechneten Hashwert des Nutzer-Passworts ''u\_key''.
\item[B)] TGT, welches folgende Daten enthält: Nutzer-ID, Netzwerkadresse des Clients, Gültigkeitsdauer des TGT und den TGS-Sitzungsschlüssel ''tgs\_session\_key''. Dieses Paket ist mit dem geheimen Schlüssel des TGS ''tgs\_key'' verschlüsselt.
\end{itemize}
Nach Erhalt der beiden Pakete versucht der Client Paket A mit dem geheimen Schlüssel ''u\_key'' zu entschlüsseln, den er aus dem Passwort berechnet, das der Nutzer eingegeben hat. Falls das durch den Nutzer eingegebene Passwort mit dem Passwort aus der Datenbank des AS übereinstimmt, kann der Client das Paket entschlüsseln. Er erhält somit den TGS-Sitzungsschlüssel ''tgs\_session\_key''. Nun hat der Client alle Informationen, die er braucht, um sich gegenüber dem TGS zu authentifizieren.
\item[3)] Sobald der Client einen Dienst anfragen will, muss er zur Vorbereitung dem TGS folgende Nachrichten schicken:
\begin{itemize}
\item[C)] Paket, das aus dem immernoch verschlüsselten TGT und der ID des angeforderten Services zusammengesetzt ist.
\item[D)] Authentifizierungspaket, das aus der Nutzer-ID ''u\_id'' und einem Zeitstempel ''timestamp'' besteht. Dieses Paket ist mit dem TGS-Sitzungsschlüssel ''tgs\_session\_key'' verschlüsselt.
\end{itemize}
Nach Erhalt dieser Pakete extrahiert der TGS das TGT aus Paket C. Das TGT entschlüsselt er wiederum mit seinem geheimen Schlüssel ''tgs\_key''. Der TGS erhält somit den TGS-Sitzungsschlüssel ''tgs\_session\_key'', welchen er zum Entschlüsseln von Paket D verwendet. Er vergleicht nun die Nutzer-IDs aus den beiden erhaltenen Paketen. Falls diese übereinstimmen, war die Authentifizierung des Clients gegenüber dem TGS erfolgreich.
\item[4)] Falls die Authentifizierung erfolgreich war, sendet der TGS folgende Nachrichten zurück an den Client:

\begin{itemize}
\item[E)] Service-Ticket, welches die Nutzer-ID ''u\_id'', die Netzwerkadresse des Clients, eine Gültigkeitsdauer und den Service-Sitzungsschlüssel ''s\_session\_key'' enthält. Dieses Paket ist mit dem geheimen Schlüssel des angefragten Service ''s\_key'' verschlüsselt.
\item[F)] Service-Sitzungsschlüssel ''s\_session\_key''. Dieses Paket ist mit dem TGS-Sitzungsschlüssel ''tgs\_session\_key'' verschlüsselt.
\end{itemize}
Nach Erhalt dieser Pakete hat der Client alle Informationen, die er benötigt, um sich gegenüber dem Service Server zu authentifizieren.
\item[5)] Der Client sendet dem Service Server folgende Nachrichten:

\begin{itemize}
\item[E)] das Paket E aus 4)
\item[G)] Ein neues Authentifizierungspaket, das die Nutzer-ID ''u\_id'' und einen Zeitstempel ''timestamp'' enthält. Dieses Paket ist mit dem Service-Sitzungsschlüssel ''s\_session\_key'' verschlüsselt.
\end{itemize}
Der Service Server entschlüsselt Paket E mit seinem eigenen geheimen Schlüssel ''s\_key''. Er erhält somit den Service-Sitzungsschlüssel ''s\_session\_key'', mit welchem er wiederum Paket G entschlüsselt. Falls die Nutzer-IDs aus Paket E und Paket G übereinstimmen, hat sich der Client erfolgreich gegenüber dem Service Server authentifiziert.
\item[6)] Zum Bestätigen der Authentifizierung sendet der Service Server dem Client folgendes Paket:

\begin{itemize}
\item[H)] Die Summe aus dem Zeitstempel ''timestamp'' aus Paket G und dem Wert 1. Dieses Paket ist mit dem Service-Sitzungsschlüssel ''s\_session\_key'' verschlüsselt.
\end{itemize}
Der Client entschlüsselt Paket H und vergleicht die enthaltene Summe mit seinem zuvor gesendeten Zeitstempel. Falls er das erwartete Ergebnis erhält, kann er dem Service Server vertrauen.

\end{itemize}
AS und TGS bilden zusammen das KDC und sind oft im selben Rechner untergebracht.