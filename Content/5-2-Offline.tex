\subsection{Offline-Attacken}
Wenn eine sich Brute-Force- (\ref{pth:bruteforce}) oder Wörterbuchattacke (\ref{pth:dictattack}) lokal und ohne Netzwerkinteraktion ausführen lässt, spricht man von einer \emph{Offline}-Attacke.
Ziel ist es zu einem erbeuteten Passwort-Hash das Klartext-Passwort herauszufinden.

\subsubsection{Hashes
  \protect\footnote{\url{https://de.wikipedia.org/wiki/Hashfunktion}}
  \protect\footnote{\url{https://de.wikipedia.org/wiki/Kryptographische_Hashfunktion}}
}
Eine Hashfunktion ist eine Abbildung, die eine große Eingabemenge (die Schlüssel) auf eine kleinere Zielmenge (die Hashwerte) abbildet. Eine Hashfunktion ist daher im Allgemeinen nicht injektiv. Die Eingabemenge kann Elemente unterschiedlicher Längen enthalten, die Elemente der Zielmenge haben dagegen meist eine feste Länge. \cite{WikipediaHashes} \\
Eine kryptologische Hashfunktion oder kryptografische Hashfunktion ist eine spezielle Form einer Hashfunktion, welche kollisionsresistent ist. Es ist also praktisch nicht möglich, zwei unterschiedliche Eingabewerte zu finden, die einen identischen Hashwert ergeben. \cite{WikipediaCryptoHashes}


\paragraph{Was bringt uns das?}
Nehmen wir zum Beispiel Server \emph{S} mit einer Benutzerdatenbank, in der Benutzer und deren Passwörter im Klartext gespeichert werden. Gelangt Angreifer \emph{A} an diese Datenbank, kann er sich bei \emph{S} als jeder Nutzer anmelden und bei anderen Servern testen ob die Nutzer eventuell das selbe Passwort angegeben haben. Werden nun anstatt der Passwörter nur die Passwort-Hashes gespeichert, kann der Angreifer nicht ohne Weiteres die eigentlichen Passwörter herausfinden.
Alles was \emph{A} übrig bleibt, ist ein Passwort zu raten und zu prüfen ob dessen Hashwert in der Datenbank vorkommt.
Mit spezialisierter Hardware und leistunsstarken GPUs können abhängig von der Hashfunktion mehre hundert Milliarden Passwörter in der Sekunde ausprobiert werden. Beispiel: Mit einer einzelnen \emph{Nvidia GTX 1080} können schon etwa 2.865.200.000 SHA256-Hashes in der Sekunde berechnet werden.\\
Interessierte finden im Netz (z.B. auf GitHub\footnote{\url{https://gist.github.com/epixoip/a83d38f412b4737e99bbef804a270c40}}) Benchmarks für die gebräuchlichsten Hashfunktionen.


Trivia: Eine weiterer Offline-Angriff ist eine so genannte \emph{Rainbow Table}\footnote{\url{https://de.wikipedia.org/wiki/Rainbow_Table}}. Diese können jedoch recht einfach durch das
\emph{Salting}\footnote{\url{https://de.wikipedia.org/wiki/Salt_(Kryptologie)}} des Passwort-Hashes verhindert werden kann.
Stand der Technik um Passwörter abzuspeichern ist
\emph{Bcrypt}\footnote{\url{https://de.wikipedia.org/wiki/Bcrypt}} welches bereits einen Salt beinhaltet.
\emph{scrypt}\footnote{\url{https://de.wikipedia.org/wiki/Scrypt}} welches dazu noch das hashen auf GPUs und ASICs verhindert ist noch relativ neu und unerprobt, gilt aber als eine Alternative.


\subsubsection{Hash-Identifier
  \protect\footnote{\url{https://code.google.com/archive/p/hash-identifier/}}
}
Interaktives Tool um anhand eines gegebenen Hashwertes die Hashfunktion herauszufinden, mit der der Hashwert erzeugt wurde.  Bei Eingabe eines Hashwertes gibt Hash-Identifier eine Liste an Wahrscheinlichen und eine Liste mit zumindest möglichen Hashfunktionen zurück. Leider unterstützt das Tool keine Parameter.


\subsubsection{John The Ripper
  \protect\footnote{\url{https://de.wikipedia.org/wiki/John_the_Ripper}}
  \protect\footnote{\url{https://www.openwall.com/john/}}
}
Tool um Brute-Force- oder Wörterbuchattacken effizient auf Grafikkarten auszuführen.
Als Eingabe nimt John Dateien mit Hashwerten (fast) aller Art an.

\begin{lstlisting}
Syntax
    john [OPTIONS] [PASSWORD-FILES]
Parameter
    *@--wordlist[=FILE]@*, *@--stdin@*, *@--pipe@*:
        Quelle oder Stream des Wörterbuchs oder der Brute-Force Werte
    *@--rules[=SECTION]@*: Regeln, die auf die Input-Werte angewendet werden
    *@--format=NAME@*: Name der Hashfunktion
Beispiel
    john -wordlist=rockyou.txt --format=wpapsk wpa.hash
\end{lstlisting}


\subsubsection{Mimikatz
  \protect\footnote{\url{https://github.com/gentilkiwi/mimikatz}}
  \protect\footnote{\url{https://blog.varonis.de/was-ist-mimikatz-eine-einfuhrung/}}
  \protect\footnote{\url{https://adsecurity.org?page_id=1821}}
}
Mimikatz ist ein Open-Source-Programm, mit dem Benutzer sich Authentifizierungsdaten wie Kerberos-Tickets anzeigen lassen und diese speichern können.
Das Programm startet eine shell über die der Benutzer die verschiedenen Funktionen aufrufen kann.
Die Funktionen sind in verschiedene Module unterteit. Beispiele für Module wären:

\begin{itemize}
	\item \texttt{privilege}: Modul um mimikatz bestimmte Rechte zu erteilen.
	\item \texttt{sekurlsa}: Modul um mit dem geschützten Speicher von lsass (Local Security Authority Subsystem Service) zu interagieren, in welchem Passwörter, Schlüssel, Pin-Codes oder auch Tickets gespeichert sind.
	\item \texttt{kerberos}: Toolkit um mit Kerberos Tickets arbeiten. Es können zum Beispiel die Tickets des aktuellen Benutzers gelesen und manipuliert oder aber auch mit den richtigen Informationen Golden-Tickets erstellt werden.
	\item \texttt{minesweeper}: Liest die Positionen der Bomben im Spiel Minesweeper aus.
\end{itemize}

\begin{lstlisting}
*@~> mimikatz@* Startet die mimikatz-shell
mimikatz # *@kerberos::list@*           Kerberos Tickets des aktuellen Users
mimikatz # *@privilege::debug@*         debug-Rechte erteilen
mimikatz # *@sekurlsa::logonpasswords@* Klartext-Passwörter
mimikatz # *@sekurlsa::tickets@*        Kerberos Tickets aller User
mimikatz # *@sekurlsa::msv@*            LM/NTLM-Hashes
\end{lstlisting}

Nachdem mimikatz gestartet wurde, lesen wir zunächst alle Kerberos Tickets des aktuellen Benutzers aus. Hierfür brauchen wir keine besonderen Berechtigungen.
Um allerdings auf den geschützen Passwortspeicher zuzugreifen, müssen wir mimikatz mittels \texttt{privilege::debug} debug-Rechte erteilen. Jetzt können wir uns mit \texttt{sekurlsa::logonpasswords} alle gespeicherten Klartext-Passwörter oder mit\\
\texttt{sekurlsa::tickets} die Kerberos Tickets aller Benutzer auf dem System ausgeben lassen. Um an die NTLM-Hashes für einen Pass-the-Hash angriff zu kommen führen wir noch \texttt{sekurlsa::msv} aus.
