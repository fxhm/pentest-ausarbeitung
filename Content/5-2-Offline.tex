

\subsection{Hashes allgemein}
Eine Hashfunktion ist eine Abbildung, die eine große Eingabemenge (die Schlüssel) auf eine kleinere Zielmenge (die Hashwerte) abbildet. Eine Hashfunktion ist daher im Allgemeinen nicht injektiv. Die Eingabemenge kann Elemente unterschiedlicher Längen enthalten, die Elemente der Zielmenge haben dagegen meist eine feste Länge. \href{https://de.wikipedia.org/wiki/Hashfunktion}{(Wikipedia Hashfunktion)} \\
Eine kryptologische Hashfunktion oder kryptografische Hashfunktion ist eine spezielle Form einer Hashfunktion, welche kollisionsresistent ist. Es ist also praktisch nicht möglich, zwei unterschiedliche Eingabewerte zu finden, die einen identischen Hashwert ergeben. \href{https://de.wikipedia.org/wiki/Kryptographische_Hashfunktion}{(Wikipedia Krypro-Hashfunktion)}


\paragraph{Was bringt uns das?}
Nehmen wir zum Beispiel Server \emph{S} mit einer Benutzerdatenbank, in der Benutzer und deren Passwörter im Klartext gespeichert werden. Gelangt Angreifer \emph{A} an diese Datenbank, kann er sich bei \emph{S} als jeder beliebige Nutzer anmelden und bei anderen Servern testen ob die Nutzer eventuell das selbe Passwort angegeben haben. Werden nun anstatt der Passwörter nur die Passwort-Hashes gespeichert, kann der Angreifer nicht ohne Weiteres die eigentlichen Passwörter herrausfinden.
Alles was \emph{A} übrig bleibt, ist ein Passwort zu raten und zu prüfen ob dessen Hashwert in der Datenbank vorkommt. Diese Art des Angriffs nennt sich \emph{Offline} \href{https://de.wikipedia.org/wiki/Brute-Force-Methode}{Bruteforce-} oder \href{https://de.wikipedia.org/wiki/W%C3%B6rterbuchangriff}{Wörterbuchattacke}, da man sie lokal und ohne Netzwerkinteraktion ausführen kann.
Mit spezialisierter Hardware und leistunsstarken GPUs können abhängig von der Hashfunktion mehre hundert Milliarden Passwörter in der Sekunde ausprobiert werden. Beispiel: Mit einer einzelnen \emph{Nvidia GTX 1080} können schon etwa 2.865.200.000 SHA256-Hashes in der Sekunde Berechnet werden.\\
Interessierte finden im Netz (z.B. auf \href{https://gist.github.com/epixoip/a83d38f412b4737e99bbef804a270c40}{GitHub}) Benchmarks für die gebräuchlichsten Hashfunktionen.


Trivia: Eine weiterer Offline-Angriff ist eine so genannte \href{https://de.wikipedia.org/wiki/Rainbow_Table}{Rainbow Table}. Diese können jedoch recht einfach durch das
\href{https://de.wikipedia.org/wiki/Salt_(Kryptologie)}{Salting} des Passworthashes verhindert werden kann.
Stand der Technik um Passwörter abzuspeichern ist
\href{https://de.wikipedia.org/wiki/Bcrypt}{Bcrypt} welches bereits einen Salt beinhaltet.
\href{https://de.wikipedia.org/wiki/Scrypt}{scrypt} welches dazu noch das hashen auf GPUs und ASICs verhindert ist noch relativ neu und unerprobt, gilt aber als eine Alternative.


\subsubsection{Hash-Identifier}
\href{https://code.google.com/archive/p/hash-identifier/}{https://code.google.com/archive/p/hash-identifier/} \\
Interaktives Tool um anhand eines gegebenen Hashwertes die Hashfunktion herrauszufinden, mit der der Hashwert erzeugt wurde.  Bei Eingabe eines Hashwertes gibt Hash-Identifier eine Liste an Wahrscheinlichen und eine Liste mit zumindest möglichen Hashfunktionen zurück. Leider unterstützt das Tool keine Parameter.


\subsubsection{John The Ripper}
\href{https://de.wikipedia.org/wiki/John_the_Ripper}{https://de.wikipedia.org/wiki/John\_the\_Ripper}
\href{https://www.openwall.com/john/}{https://www.openwall.com/john/}
Tool um Bruteforce- oder Wörterbuchattacken effizient auf Grafikkarten auszuführen.\\
Als eingabe nimt John Dateien mit Hashwerten (fast) aller Art an. Syntax:\\
\inlinecode{}{john [OPTIONS] [PASSWORD-FILES]}

Wichtige Optionsparameter:
\begin{itemize}
\item \inlinecode{}{--wordlist[=FILE]}, \inlinecode{}{--stdin} oder \inlinecode{}{--pipe} Quelle oder Stream des Wörterbuchs oder der Bruteforce Werte
\item \inlinecode{}{--rules[=SECTION]} Regeln, die auf die Input-Werte angewendet werden
\item \inlinecode{}{--format=NAME} Name der Hashfunktion
\end{itemize}
Beispiel:\\
\inlinecode{}{john -wordlist=rockyou.txt --format=wpapsk wpa.hash}


\subsubsection{Mimikatz}
\href{https://github.com/gentilkiwi/mimikatz}{https://github.com/gentilkiwi/mimikatz} \\
\href{https://blog.varonis.de/was-ist-mimikatz-eine-einfuhrung/}{https://blog.varonis.de/was-ist-mimikatz-eine-einfuhrung/} \\
\href{https://adsecurity.org?page_id=1821}{https://adsecurity.org/?page\_id=1821} \\
Mimikatz ist ein Open-Source-Programm, mit dem Benutzer sich Authentifizierungsdaten wie Kerberos-Tickets anzeigen lassen und diese speichern können.
Das Programm startet eine "Mimikatz Console" über die der Benutzer die verschiedenen Funktionen aufrufen kann.
Die Funktionen sind in verschiedene Module unterteit. Beispiele für Module wären:


\emph{PRIVILEGE} \\
Modul um mimikatz bestimmte Rechte zu erteilen. Zum Beispiel brauchen Funktionen, die auf den Speicher anderer Prozesse auslesen sollen das "debug"-Recht. Dieses wird mit dem Befehl "privilege::debug" erteilt \\
\emph{SEKURLSA} \\
Modul um mit dem geschützten Speicher von lsass (Local Security Authority Subsystem Service) zu interagieren, in welchem Passwörter, Schlüssel, Pin-Codes oder auch Tickets gespeichert sind.
\\
\emph{KERBEROS} \\
Toolkit um mit Kerberos Tickets arbeiten. Es können zum Beispiel die Tickets des aktuellen Benutzers gelesen und manipuliert oder aber auch mit den richtigen Informationen Golden-Tickets erstellt werden.
\\
\emph{MINESWEEPER} \\
Liest die Positionen der Bomben im Spiel Minesweeper aus.

\begin{lstlisting}[frame=single]
~> mimikatz
mimikatz # kerberos::list
mimikatz # privilege::debug
mimikatz # sekurlsa::logonpasswords
mimikatz # sekurlsa::tickets
mimikatz # sekurlsa::msv
\end{lstlisting}

Nachdem mimikatz gestartet wurde, lesen wir zunächst alle Kerberos Tickets des aktuellen Benutzers aus. Hierfür brauchen wir keine besonderen Berechtigungen.
Um allerdings auf den geschützen Passwortspeicher zuzugreifen, müssen wir mimikatz mittels \inlinecode{}{privilege::debug} debug-Rechte erteilen. Jetzt können wir uns mit \inlinecode{}{sekurlsa::logonpasswords} alle gespeicherten Klartext-Passwörter oder mit \inlinecode{}{sekurlsa::tickets} die Kerberos Tickets aller Benutzer auf dem System ausgeben lassen. Um an die NTLM-Hashes für einen Pass-the-Hash angriff zu kommen führen wir noch \inlinecode{}{sekurlsa::msv} aus.
