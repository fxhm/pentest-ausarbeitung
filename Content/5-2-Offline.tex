

\subsection{Hashes allgemein}
Eine Hashfunktion ist eine Abbildung, die eine große Eingabemenge (die Schlüssel) auf eine kleinere Zielmenge (die Hashwerte) abbildet. Eine Hashfunktion ist daher im Allgemeinen nicht injektiv. Die Eingabemenge kann Elemente unterschiedlicher Längen enthalten, die Elemente der Zielmenge haben dagegen meist eine feste Länge. (Wikipedia)

Anschaulich:
md5(„asdf“) = „912ec803b2ce49e4a541068d495ab570“
md5 ist die Hashfunktion, „asdf“ ist der Schlüssel und „912ec803b2ce49e4a541068d495ab570“ ist der resultierende Hashwert.

\paragraph{Wozu das ganze?}
Nehmen wir zum Beispiel Server S mit einer Benutzerdatenbank, in der Benutzer und deren Passwörter im Klartext gespeichert werden. Gelangt Angreifer A an diese Datenbank, kann er sich bei S als jeder beliebige Nutzer anmelden und bei anderen Servern testen ob die Nutzer eventuell das selbe Passwort angegeben haben.  Werden nun anstatt der Passwörter nur die Passwort-Hashes gespeichert, kann der Angreifer nicht ohne Weiteres die eigentlichen Passwörter herrausfinden.
A bleibt nichts anderes übrig als …
Rainbowtables und Salting

\subsubsection{Hash-Identifier}
\href{https://code.google.com/archive/p/hash-identifier/}{https://code.google.com/archive/p/hash-identifier/} \\
Interaktives Tool um anhand eines gegebenen Hashwertes die Hashfunktion herrauszufinden, mit der der Hashwert erzeugt wurde.  Bei Eingabe eines Hashwertes gibt Hash-Identifier eine Liste an Wahrscheinlichen und eine Liste mit zumindest möglichen Hashfunktionen zurück. Leider unterstützt das Tool keine Parameter.


\subsubsection{John The Ripper}
Tool um Bruteforce- oder Wörterbuchattacken effizient auf

\providecommand{\inlinecode}[1]{\texttt{#1}}
\subsubsection{Winexe}
Winexe ist ein Tool um auf einem Zielrechner eine Remoteshell zu öffnen. Das Prefix "pth" weist darauf hin, dass zur Authentifizierung auf dem Zielrechner ein Pass-the-Hash Angriff benutzt wird.
Benutzung:
pth-winexe [OPTION]... //HOST COMMAND
//HOST - Der Zielrechner
COMMAND - der Befehl, der auf dem Zielrechner ausgeführt werden soll. Um eine Commandline zu starten kann "cmd" aangegeben werden.
Mit der Option --user kann der User mit folgender Syntax angegeben werden:
\begin{lstlisting}[frame=single]
--user=[DOMAIN/]USERNAME[\%PASSWORD]
\end{lstlisting}
Das Passwort entspricht dabei dem Passwort-Hash.
Beispiel:
\begin{lstlisting}[frame=single]
pth-winexe --user=root\%912ec80329e:a38463fc216 //192.168.178.20 cmd
\end{lstlisting}

\subsubsection{Mimikatz}
\href{https://github.com/gentilkiwi/mimikatz}{https://github.com/gentilkiwi/mimikatz} \\
\href{https://blog.varonis.de/was-ist-mimikatz-eine-einfuhrung/}{https://blog.varonis.de/was-ist-mimikatz-eine-einfuhrung/} \\
\href{https://adsecurity.org?page_id=1821}{https://adsecurity.org/?page\_id=1821} \\
Mimikatz ist ein Open-Source-Programm, mit dem Benutzer sich Authentifizierungsdaten wie Kerberos-Tickets anzeigen lassen und diese speichern können.
Das Programm startet eine "Mimikatz Console" über die der Benutzer die verschiedenen Funktionen aufrufen kann.
Die Funktionen sind in verschiedene Module unterteit. Beispiele für Module wären:


\emph{PRIVILEGE} \\
Modul um mimikatz bestimmte Rechte zu erteilen. Zum Beispiel brauchen Funktionen, die auf den Speicher anderer Prozesse auslesen sollen das "debug"-Recht. Dieses wird mit dem Befehl "privilege::debug" erteilt \\
\emph{SEKURLSA} \\
Modul um mit dem geschützten Speicher von lsass (Local Security Authority Subsystem Service) zu interagieren, in welchem Passwörter, Schlüssel, Pin-Codes oder auch Tickets gespeichert sind.
\\
\emph{KERBEROS} \\
Toolkit um mit Kerberos Tickets arbeiten. Es können zum Beispiel die Tickets des aktuellen Benutzers gelesen und manipuliert oder aber auch mit den richtigen Informationen Golden-Tickets erstellt werden.
\\
\emph{MINESWEEPER} \\
Liest die Positionen der Bomben im Spiel Minesweeper aus.

\begin{lstlisting}[frame=single]
~> mimikatz
mimikatz # kerberos::list
mimikatz # privilege::debug
mimikatz # sekurlsa::logonpasswords
mimikatz # sekurlsa::tickets
mimikatz # sekurlsa::msv
\end{lstlisting}

Nachdem mimikatz gestartet wurde, lesen wir zunächst alle Kerberos Tickets des aktuellen Benutzers aus. Hierfür brauchen wir keine besonderen Berechtigungen.
Um allerdings auf den geschützen Passwortspeicher zuzugreifen, müssen wir mimikatz mittels "privilege::debug" debug-Rechte erteilen. Jetzt können wir uns mit "sekurlsa::logonpasswords" alle gespeicherten Klartext-Passwörter oder mit "sekurlsa::tickets" die Kerberos Tickets aller Benutzer auf dem System ausgeben lassen. Um an die NTLM-Hashes für einen Pass-the-Hash angriff zu kommen führen wir noch "sekurlsa::msv" aus.
